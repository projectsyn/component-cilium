apiVersion: v1
kind: ServiceAccount
metadata:
  annotations: {}
  labels:
    name: egress-ip-self-service
  name: egress-ip-self-service
  namespace: cilium
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations: {}
  labels:
    name: cilium-self-service-egress-ip
  name: cilium:self-service-egress-ip
rules:
  - apiGroups:
      - ''
    resources:
      - namespaces
    verbs:
      - get
      - list
      - watch
      - patch
  - apiGroups:
      - espejote.io
    resources:
      - jsonnetlibraries
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - isovalent.com
    resources:
      - isovalentegressgatewaypolicies
    verbs:
      - '*'
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  annotations: {}
  labels:
    name: cilium-self-service-egress-ip
  name: cilium:self-service-egress-ip
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cilium:self-service-egress-ip
subjects:
  - kind: ServiceAccount
    name: egress-ip-self-service
    namespace: cilium
---
apiVersion: espejote.io/v1alpha1
kind: JsonnetLibrary
metadata:
  labels:
    app.kubernetes.io/name: egress-gateway
  name: egress-gateway
  namespace: cilium
spec:
  data:
    config.json: |-
      {
          "egress_ranges": [
              {
                  "destination_cidrs": [

                  ],
                  "egress_range": "192.0.2.32 - 192.0.2.63",
                  "if_prefix": "egress_a",
                  "namespace_egress_ips": {
                      "bar": "192.0.2.61",
                      "baz": null,
                      "foo": "192.0.2.32"
                  },
                  "node_selector": {
                      "node-role.kubernetes.io/infra": ""
                  },
                  "policy_labels": {
                      "cilium.syn.tools/test": "additional-policy-label"
                  },
                  "shadow_ranges": {
                      "infra-8344": "198.51.100.0 - 198.51.100.31",
                      "infra-87c9": "198.51.100.32 - 198.51.100.63",
                      "infra-eba2": "198.51.100.64 - 198.51.100.95"
                  }
              },
              {
                  "bgp_policy_labels": {

                  },
                  "destination_cidrs": [
                      "203.0.113.0/24"
                  ],
                  "egress_cidr": "192.0.2.64/27",
                  "if_prefix": "egress_c",
                  "namespace_egress_ips": {
                      "baz": "192.0.2.93"
                  },
                  "node_selector": {
                      "node-role.kubernetes.io/infra": ""
                  },
                  "shadow_ranges": {
                      "infra-8344": "198.51.100.96 - 198.51.100.127",
                      "infra-87c9": "198.51.100.128 - 198.51.100.159",
                      "infra-eba2": "198.51.100.160 - 198.51.100.191"
                  }
              },
              {
                  "egress_range": "192.0.2.96 - 192.0.2.127",
                  "if_prefix": "egress_d",
                  "namespace_egress_ips": {

                  },
                  "node_selector": {
                      "node-role.kubernetes.io/infra": ""
                  }
              },
              {
                  "egress_range": "192.0.2.128 - 192.0.2.159",
                  "if_prefix": "egress_e",
                  "namespace_egress_ips": {

                  },
                  "node_selector": {
                      "node-role.kubernetes.io/infra": ""
                  },
                  "shadow_ranges": null
              },
              {
                  "bgp_policy_labels": {
                      "cilium.syn.tools/egress-ip": "bgp"
                  },
                  "destination_cidrs": [
                      "203.0.113.0/25"
                  ],
                  "egress_cidr": "192.0.2.160/27",
                  "if_prefix": "egress_f",
                  "namespace_egress_ips": {
                      "qux": "192.0.2.160"
                  },
                  "node_selector": {
                      "node-role.kubernetes.io/infra": ""
                  },
                  "skip_last": true
              }
          ]
      }
    egress-gateway.libsonnet: |
      local ipcalc = import 'ipcalc.libsonnet';

      local CiliumEgressGatewayPolicy(name) = {
        apiVersion: 'cilium.io/v2',
        kind: 'CiliumEgressGatewayPolicy',
        metadata+: {
          name: name,
          labels: {
            name: name,
          },
          annotations: {
            'argocd.argoproj.io/sync-options': 'SkipDryRunOnMissingResource=true,Prune=false',
          },
        },
      };

      local IsovalentEgressGatewayPolicy(name) = {
        apiVersion: 'isovalent.com/v1',
        kind: 'IsovalentEgressGatewayPolicy',
        metadata+: {
          name: name,
          labels: {
            name: name,
          },
          annotations: {
            'argocd.argoproj.io/sync-options': 'SkipDryRunOnMissingResource=true,Prune=false',
          },
        },
      };

      // Per-namespace egress IPs according to the selected design choice in
      // https://kb.vshn.ch/oc4/explanations/decisions/cloudscale-cilium-egressip.html
      // Requires that the shadow IPs are assigned to suitable dummy interfaces on
      // the hosts matching the node selector and that SNAT rules are in place to
      // map the shadow ranges to the public range.
      local NamespaceEgressPolicy =
        function(
          interface_prefix,
          egress_range,
          shadow_ranges,
          node_selector,
          egress_ip,
          namespace,
          policy_resource_fn,
          destination_cidrs=null,
          bgp_policy_labels={},
          policy_labels={},
        )
          // Helper which computes the interface index of the egress IP.
          // Assumes that the IPs in egress_range are assigned to dummy interfaces
          // named
          //
          //   "<interface_prefix>_<i>"
          //
          // where i = 0..length(egress_range) - 1.
          local ifindex =
            local range = ipcalc.parse_ip_range(interface_prefix, egress_range);
            local start = ipcalc.ipval(range.start);
            local end = ipcalc.ipval(range.end);
            local ip = ipcalc.ipval(egress_ip);
            if start > end then
              error 'Egress IP range for "%s" is empty: %s > %s' % [
                interface_prefix,
                range.start,
                range.end,
              ]
            else if start > ip || end < ip then
              error 'Egress IP for namespace "%s" (%s) outside of configured IP range (%s) for egress range "%s"' % [
                namespace,
                egress_ip,
                egress_range,
                interface_prefix,
              ]
            else
              local idx = ip - start;
              local name = '%s_%d' % [ interface_prefix, idx ];
              if std.length(name) > 15 then
                error 'Interface name is longer than 15 characters: %s' % [ name ]
              else
                {
                  value: idx,
                  ifname: '%s_%d' % [ interface_prefix, idx ],
                  debug: 'start=%d, end=%d, ip=%d' % [ start, end, ip ],
                };

          local compute_shadow_ip(shadow_range) =
            local range = ipcalc.parse_ip_range('shadow', shadow_range);
            local start = ipcalc.ipval(range.start);
            ipcalc.format_ipval(start + ifindex.value);

          local shadow_ips = [
            compute_shadow_ip(r)
            for r in shadow_ranges
          ];

          local dest_cidrs = if destination_cidrs == null || std.length(destination_cidrs) == 0 then
            [ '0.0.0.0/0' ]
          else
            assert
              std.isArray(destination_cidrs)
              : 'Expected `destination_cidrs` to be an array, got %s' % std.type(destination_cidrs);
            destination_cidrs;

          local bgp_egress_ip = std.length(bgp_policy_labels) > 0;

          policy_resource_fn(namespace) {
            metadata+: {
              annotations+: {
                'cilium.syn.tools/description':
                  'Generated policy to assign %segress IP %s in egress range "%s" (%s) to namespace %s.' % [
                    if bgp_egress_ip then 'BGP ' else '',
                    egress_ip,
                    interface_prefix,
                    egress_range,
                    namespace,
                  ],
                [if bgp_egress_ip then 'cilium.syn.tools/experimental-policy']: 'true',
                'cilium.syn.tools/egress-ip': egress_ip,
                'cilium.syn.tools/interface-prefix': interface_prefix,
                'cilium.syn.tools/egress-range': egress_range,
                'cilium.syn.tools/source-namespace': namespace,
                [if !bgp_egress_ip then 'cilium.syn.tools/debug-interface-index']: ifindex.debug,
                [if std.length(shadow_ips) > 0 then 'cilium.syn.tools/shadow-ips']:
                  std.manifestJsonMinified(shadow_ips),
              },
              labels+: policy_labels + bgp_policy_labels,
            },
            spec: {
              destinationCIDRs: dest_cidrs,
              [if bgp_egress_ip then 'egressCIDRs']: [ '%s/32' % egress_ip ],
              egressGroups: [
                {
                  nodeSelector: {
                    matchLabels: node_selector,
                  },
                } + if bgp_egress_ip then {
                  maxGatewayNodes: 1,
                } else {
                  interface: ifindex.ifname,
                },
              ],
              selectors: [
                {
                  podSelector: {
                    matchLabels: {
                      'io.kubernetes.pod.namespace': namespace,
                    },
                  },
                },
              ],
            },
          };

      local espejoteLabel = {
        'cilium.syn.tools/managed-by': 'espejote_cilium_namespace-egress-ips',
      };

      // read_egress_range extracts the egress range from the passed config object,
      // either from field `egress_range` or from field `egress_cidr`.
      // When reading from field `egress_cidr` the function also respects fields
      // `skip_first` and `skip_last` when generating the resulting range object.
      local read_egress_range(prefix, config) =
        local ekey = std.setDiff(
          std.set([ 'egress_range', 'egress_cidr' ]),
          std.set(std.objectFields(config))
        );
        if std.length(ekey) != 1 then
          error
            'egress_ip_ranges` entries are expected to have exactly one of ' +
            '`egress_range` and `egress_cidr`. entry "%s" has %s.' % [
              prefix,
              if std.length(ekey) == 2 then 'neither'
              else if std.length(ekey) == 0 then 'both'
              else 'a weird configuration',
            ]
        else
          if std.objectHas(config, 'egress_range') then
            local erange = ipcalc.parse_ip_range(prefix, config.egress_range);
            erange
          else
            local ecidr = ipcalc.parse_cidr(prefix, config.egress_cidr);
            {
              start: if std.get(config, 'skip_first', false) then
                ecidr.host_min
              else
                ecidr.network_address,
              end: if std.get(config, 'skip_last', false) then
                ecidr.host_max
              else
                ecidr.broadcast_address,
            };


      // find_egress_range expects a list of egress range objects which contain the
      // interface prefix in a field. This list is precomputed by the Commodore
      // component and provided to the Espejote template as
      // `"config.json".egress_ranges`.
      // This function returns an object with field `range` containing the range of
      // the IP if unique or `null` if not unique or not found, and field `errmsg`
      // containing an error message if `range` is null.
      local find_egress_range(ranges, egress_ip) =
        local eip = ipcalc.ipval(egress_ip);
        local check_fn(rspec) =
          local range = read_egress_range(rspec.if_prefix, rspec);
          local start = ipcalc.ipval(range.start);
          local end = ipcalc.ipval(range.end);
          eip >= start && eip <= end;
        local filtered = std.filter(check_fn, ranges);
        if std.length(filtered) == 1 then {
          range: filtered[0],
          errmsg: '',
        } else {
          local read_erange_str(r) =
            local er = read_egress_range(r.if_prefix, r);
            '%(start)s - %(end)s' % er,
          range: null,
          errmsg: if std.length(filtered) == 0 then
            local eranges = std.join(', ', [ read_erange_str(r) for r in ranges ]);
            'No egress range found for %s, available ranges: %s'
            % [ egress_ip, eranges ]
          else
            local eranges = std.join(
              ', ', [ '%s (%s)' % [ r.if_prefix, read_erange_str(r) ] for r in filtered ]
            );
            'Found multiple egress ranges which contain %s: %s. ' % [ egress_ip, eranges ] +
            "Please contact your cluster's administrator to resolve this range overlap",
        };

      {
        CiliumEgressGatewayPolicy: CiliumEgressGatewayPolicy,
        IsovalentEgressGatewayPolicy: IsovalentEgressGatewayPolicy,
        NamespaceEgressPolicy: NamespaceEgressPolicy,
        espejoteLabel: espejoteLabel,
        find_egress_range: find_egress_range,
        read_egress_range: read_egress_range,
      }
    ipcalc.libsonnet: |
      // NOTE(sg): This file is symlinked to `component/espejote-templates` in
      // component-cilium to allow the `espejote-templates/egress-gateway.libsonnet`
      // library to work regardless of whether it's used by Espejote or the
      // component. We export this as a component library since it might be useful
      // for other components on Cilium-enabled clusters.

      // Convert an IPv4 address in A.B.C.D format that's already been split into an
      // array to decimal format according to the formula `A*256^3 + B*256^2 + C*256
      // + D`. The decimal format allows us to make range comparisons and compute
      // offsets into a range.
      // Parameter ip can either be the IP as a string, or already split into an
      // array holding each dotted part.
      local ipval(ip) =
        local iparr =
          if std.type(ip) == 'array' then
            ip
          else
            std.split(ip, '.');
        local iparr_int = std.map(std.parseInt, iparr);

        if std.any(std.map(function(v) v > 255, iparr_int)) then
          error 'Error parsing IPv4 address: %s is not a valid address' % [
            ip,
          ]
        else
          std.foldl(
            function(v, p) v * 256 + p,
            iparr_int,
            0
          );

      // Extract start and end from the provided range, stripping any
      // whitespace. `prefix` is only used for the error message.
      local parse_ip_range(prefix, rangespec) =
        local range_parts = std.map(
          function(s) std.stripChars(s, ' '),
          std.split(rangespec, '-')
        );
        if std.length(range_parts) != 2 then
          error 'Expected IP range for "%s" in format "192.0.2.32-192.0.2.63",  got %s' % [
            prefix,
            rangespec,
          ]
        else
          {
            start: range_parts[0],
            end: range_parts[1],
          };

      local format_ipval(val) =
        assert
          val >= 0 && val <= ipval('255.255.255.255')
          : '%s not an IPv4 address in decimal' % val;

        local iparr = std.reverse(std.foldl(
          function(st, i)
            local arr = st.arr;
            local rem = st.rem;
            {
              arr: arr + [ rem % 256 ],
              rem: rem / 256,
            },
          [ 0, 0, 0, 0 ],
          { arr: [], rem: val }
        ).arr);

        std.join('.', std.map(function(v) '%d' % v, iparr));

      // Parse network in CIDR notation. Leading and trailing whitespace is
      // stripped. `prefix` is only used for the error message.
      //
      // This function correctly parses the full network info from arbitrary IPs in
      // CIDR notation. We return an object that's inspired by the output of the
      // Linux utility `ipcalc`.
      //
      // The return value contains the network address, broadcast address, count of
      // IPs in the CIDR and prefix length. For prefix lengths of less than 32, the
      // return value additionally contains the first and last host (in `min_host`
      // and `max_host`) and netmask.
      local parse_cidr(prefix, cidr) =
        local parts = std.split(std.stripChars(cidr, ' '), '/');
        if std.length(parts) != 2 then
          error 'Expected value for "%s" to be in CIDR notation, got "%s"' % [
            prefix,
            cidr,
          ]
        else
          local prefix_length = std.parseInt(parts[1]);
          if prefix_length < 0 || prefix_length > 32 then
            error 'Invalid CIDR %s: prefix must be between 0 and 32' % cidr
          else
            // We compute count, netmask and network address using bitwise operations.
            // Jsonnet uses 64 bit integers for bitwise ops, so we don't have to worry
            // about overflowing when working with 32 bit values (IPv4 addresses).
            //
            // IPv4 CIDR notation works as follows: <addr>/<prefix> defines a network
            // where the first <prefix> bits of the IP are the "network" and the last
            // 32-<prefix> bits are (mostly) freely selectable for addresses within
            // that network.
            //
            // Bitwise glossary:
            //  - (1 << n) == 2**n
            //  - `&` is bitwise and (setting all bits that are set in either operand)
            //  - `~` is bitwise not (flipping all bits of the operand)
            // Jsonnet operator precedence: binary +- bind higher than shifts

            // count is the number of available addresses (including the network and
            // broadcast address in the network). It's a value which has the
            // 32-<prefix> low bits set to 1 and all other bits set to 0.
            local count = (1 << 32 - prefix_length) - 1;
            // Netmask has the high <prefix> bits set to one and the 32-<prefix> low
            // bits set to 0. We can use `~count` as the mask to set the low
            // 32-<prefix> bits to 0, since count has only these bits set to 1 and
            // bitwise not flips all bits.
            local netmask = ((1 << 32) - 1) & ~count;
            // The network address is the first address in the network. By converting
            // the specified <addr> to an integer and using the netmask to set the low
            // 32-<prefix> bits to 0 we reliably get the network address regardless of
            // which IP in the network that the user specified for a given prefix.
            local net_addr = ipval(parts[0]) & netmask;

            {
              network_address: format_ipval(net_addr),
              broadcast_address: format_ipval(net_addr + count),
              prefix_length: prefix_length,
              count: count,
            } + if prefix_length < 32 then {
              host_min: format_ipval(net_addr + 1),
              host_max: format_ipval(net_addr + count - 1),
              netmask: format_ipval(netmask),
            } else {};

      {
        ipval: ipval,
        parse_ip_range: parse_ip_range,
        parse_cidr: parse_cidr,
        format_ipval: format_ipval,
      }
---
apiVersion: espejote.io/v1alpha1
kind: ManagedResource
metadata:
  annotations:
    syn.tools/description: |
      This managed resource enables users to configure egress IPs for their
      namespaces by setting annotation `cilium.syn.tools/egress-ip` to an
      egress IP that's within a configured egress range for the cluster.

      Egress ranges are configured via Project Syn with component-cilium.
      The managed resource uses the same configuration which the component
      uses to configure the ranges to determine which range an egress IP
      belongs. If users specify an egress IP that doesn't belong to any
      range, or if overlapping ranges are configured, the managed resource
      emits an error as an annotation on the namespace which requests the
      egress IP.

      If the egress IP can be mapped to a range uniquely, the managed
      resource creates an IsovalenEgressGatewayPolicy which sets the desired
      egress IP for all traffic originating in that namespace. The policy
      uses the same logic as the Commodore component to map the egress IP to
      a Linux interface name.

      Users can change egress IPs for namespaces by editing the
      `cilium.syn.tools/egress-ip` annotation.

      Users can remove egress IPs from namespaces by removing the
      `cilium.syn.tools/egress-ip` annotation (note that setting the
      annotation to an empty string is an error). If the annotation doesn't
      exist anymore, and there's an IsovalentEgressGatewayPolicy that's
      managed by us, this policy is deleted.

      To ensure that the egress IP config is cleaned up when a namespace is
      deleted, the namespace requesting the IP is set as an owner reference
      on the IsovalentEgressGatewayPolicy.
  labels:
    app.kubernetes.io/name: namespace-egress-ips
  name: namespace-egress-ips
  namespace: cilium
spec:
  context:
    - name: namespaces
      resource:
        apiVersion: v1
        kind: Namespace
    - name: egress_policies
      resource:
        apiVersion: isovalent.com/v1
        kind: IsovalentEgressGatewayPolicy
        labelSelector:
          matchLabels:
            cilium.syn.tools/managed-by: espejote_cilium_namespace-egress-ips
  serviceAccountRef:
    name: egress-ip-self-service
  template: |
    local esp = import 'espejote.libsonnet';

    local config = import 'egress-gateway/config.json';
    local egw = import 'egress-gateway/egress-gateway.libsonnet';
    local ipcalc = import 'egress-gateway/ipcalc.libsonnet';

    // setAnnotations is a helper that generates a minimal partial manifest to
    // set/update annotations with server-side apply.
    local setAnnotations(obj, annotations) = {
      apiVersion: obj.apiVersion,
      kind: obj.kind,
      metadata: {
        name: obj.metadata.name,
        annotations: annotations,
      },
    };

    // Collect list of namespaces for which we currently manage egress policies
    // based on the `egress_policies` context (which only contains
    // `IsovalentEgressGatewayPolicy` resources which have the `egw.espejoteLabel`
    // set).
    local managed_policies_namespaces = [
      p.metadata.name
      for p in esp.context().egress_policies
    ];

    local reconcileNamespace(namespace) =
      assert
        namespace != null && namespace.kind == 'Namespace'
        : 'reconcileNamespace() expects to be called with a Namespace resource';

      local ns_meta = namespace.metadata;
      local egress_ip = std.get(
        std.get(ns_meta, 'annotations', {}),
        'cilium.syn.tools/egress-ip'
      );

      if egress_ip != null then (
        local res = egw.find_egress_range(config.egress_ranges, egress_ip);
        if res.range != null then
          // when we have a range, generate a IsovalentEgressGatewayPolicy (with
          // ownerReference pointing to the namespace, and labeled as managed by
          // us) and update the namespace with an informational message.
          local range = res.range;
          local egress_range = egw.read_egress_range(range.if_prefix, range);
          [
            egw.NamespaceEgressPolicy(
              range.if_prefix,
              '%(start)s - %(end)s' % egress_range,
              std.objectValues(std.get(range, 'shadow_ranges', {})),
              range.node_selector,
              egress_ip,
              ns_meta.name,
              egw.IsovalentEgressGatewayPolicy,
              destination_cidrs=std.get(range, 'destination_cidrs', []),
              bgp_policy_labels=std.get(range, 'bgp_policy_labels', {}),
              policy_labels=std.get(range, 'policy_labels', {}),
            ) {
              metadata+: {
                labels+: egw.espejoteLabel,
                ownerReferences: [ {
                  controller: true,
                  apiVersion: namespace.apiVersion,
                  kind: namespace.kind,
                  name: ns_meta.name,
                  uid: ns_meta.uid,
                } ],
              },
            },
            setAnnotations(namespace, {
              'cilium.syn.tools/egress-ip-status': 'Egress IP assigned successfully',
            }),
          ]
        else
          // when we didn't find a unique egress range for the requested IP, add
          // the error message to the namespace.
          [
            setAnnotations(namespace, {
              'cilium.syn.tools/egress-ip-status': res.errmsg,
            }),
          ]
      ) else if std.member(managed_policies_namespaces, ns_meta.name) then [
        // when the namespace doesn't have an egress-ip annotation, but we have a
        // managed IsovalentEgressGatewayPolicy, delete it.
        esp.markForDelete(
          egw.IsovalentEgressGatewayPolicy(ns_meta.name)
        ),
        setAnnotations(namespace, {
          'cilium.syn.tools/egress-ip-status': 'Egress IP removed successfully',
        }),
      ];

    // check if the object is getting deleted by checking if it has
    // `metadata.deletionTimestamp`.
    local inDelete(obj) = std.get(obj.metadata, 'deletionTimestamp', '') != '';

    if esp.triggerName() == 'namespace' then (
      // Handle single namespace update on namespace trigger
      local nsTrigger = esp.triggerData();
      // nsTrigger can be null if we're called when the namespace is getting
      // deleted. If it's not null, we still don't want to do anything when the
      // namespace is getting deleted.
      if nsTrigger != null && std.get(nsTrigger, 'resource') != null && !inDelete(nsTrigger.resource) then
        reconcileNamespace(nsTrigger.resource)
    ) else
      // Reconcile all namespaces for jsonnetlibrary update or managedresource
      // reconcile.
      local namespaces = esp.context().namespaces;
      std.flattenArrays(std.prune([
        reconcileNamespace(ns)
        for ns in namespaces
        if !inDelete(ns)
      ]))
  triggers:
    - name: namespace
      watchContextResource:
        name: namespaces
    - name: config
      watchResource:
        apiVersion: espejote.io/v1alpha1
        kind: JsonnetLibrary
        name: egress-gateway
        namespace: cilium
